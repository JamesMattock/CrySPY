#!/usr/bin/env python3

### Header ###

# This script modifies the lammps input file generated by lammps-interface

# It is included in stage 2

### Import modules ###

import os

### Main ###

# List of xyz file paths needed for input
# Number of each molecule is also needed
# This will be running in the calculation directories
# Path should be modified accordingly

filename = "../../molelist"

moledata = open(filename, 'r').readlines()

molenames = []
molnums = []
mollengths = []

for line in moledata:

    moledata_line = line.split()
    
    if len(moledata_line) > 0:
    
        molenames.append(moledata_line[1])
        molnums.append(moledata_line[0])

# Calculate number and type of atoms

atom_type_list = []

for molecule in molenames:

    coordfile = "../../" + molecule
    coords = open(coordfile, 'r').readlines()
    
    mol_length = len(coords)
    mol_length = mol_length - 2
    mollengths.append(mol_length)
    
    for atom in coords:
    
        atom_line = atom.split()     
    
        if len(atom_line) > 1:
        
            atom_type_list.append(atom_line[0])
            
sort_atoms = sorted(atom_type_list)

num_of_atoms = len(sort_atoms)

atom_types = []
num_atoms_of_type = []

atom_types.append(sort_atoms[0])
type_ctr = 0
num_types = 1
comp_var = sort_atoms[0]

# Create a list of atoms types
# This needs to be ordered in the same way as the CrySPY input

for atom in sort_atoms:

    if atom == comp_var:
        
        type_ctr = type_ctr + 1
        
    else:
    
        atom_types.append(atom)
        num_atoms_of_type.append(type_ctr)
        type_ctr = 1
        comp_var = atom
        
num_atoms_of_type.append(type_ctr)

print(num_atoms_of_type) # For debugging

# Get the charges from the extracted Mulliken charges
# This will be running in the calculation directories
# Path should be modified accordingly

collated_file = "../../generation/charge_output.text"

raw_charges = open(collated_file, 'r').readlines()

charge_type_ctr = len(atom_types)
mol_ordered_charges = []
ordered_charges = []

start_ctr = 0
end_ctr = 0

# molnums is the number of of each type of molecule in the cell

mol_ctr = len(molnums)

for mol in range(0, mol_ctr):

    start_ctr = end_ctr + 2

    for x in range(0, charge_type_ctr):

        end_ctr = end_ctr + num_atoms_of_type[x]
        
        for y in range(0, int(molnums[mol])): 
        
            for z in range(start_ctr, end_ctr):
        
                mol_ordered_charges.append(raw_charges[z])
            
for x_2 in range(0, charge_type_ctr):

    for charge_line in mol_ordered_charges:
    
        data = charge_line.split()
        
        if data[1] == atom_types[x_2]:
        
            ordered_charges.append(data[2])
            
# Get header info from data.potentials
# This is the potentials file generated by LAMMPS Interface

data_file = "data.potentials"

pote_data = open(data_file, 'r').readlines()

# Generate variables to hold index lines for each section

final_line = len(pote_data)
bonds_line = 0
angles_line = 0
dihedrals_line = 0
impropers_line = 0
bond_types_line = 0
angle_types_line = 0
dihedral_types_line = 0
improper_types_line = 0

# Generate variables to hold the amounts
# This is required for loop counting

bonds_num = 0
angles_num = 0
dihedrals_num = 0
impropers_num = 0
bond_types_num = 0
angle_types_num = 0
dihedral_types_num = 0
improper_types_num = 0

# Find each section in the data.potentials file

# Number of Bonds

for line in pote_data:
    if line.find('Bonds') != -1:
        bonds_line = pote_data.index(line)

for bonds_x in range((bonds_line+2), final_line):
    inspect_line = pote_data[bonds_x].split()
    if len(inspect_line) > 1:
        bonds_num = bonds_num + 1
    else:
        break

# Number of Angles

for line in pote_data:
    if line.find('Angles') != -1:
        angles_line = pote_data.index(line)

for angles_x in range((angles_line+2), final_line):
    inspect_line = pote_data[angles_x].split()
    if len(inspect_line) > 1:
        angles_num = angles_num + 1
    else:
        break
        
# Number of Dihedrals

for line in pote_data:
    if line.find('Dihedrals') != -1:
        dihedrals_line = pote_data.index(line)

for dihedrals_x in range((dihedrals_line+2), final_line):
    inspect_line = pote_data[dihedrals_x].split()
    if len(inspect_line) > 1:
        dihedrals_num = dihedrals_num + 1
    else:
        break

# Number of Impropers

for line in pote_data:
    if line.find('Impropers') != -1:
        impropers_line = pote_data.index(line)

for impropers_x in range((impropers_line+2), final_line):
    inspect_line = pote_data[impropers_x].split()
    if len(inspect_line) > 1:
        impropers_num = impropers_num + 1
    else:
        break

# Number of Bond Types

for line in pote_data:
    if line.find('Bond Coeffs') != -1:
        bond_types_line = pote_data.index(line)

for bond_types_x in range((bond_types_line+2), final_line):
    inspect_line = pote_data[bond_types_x].split()
    if len(inspect_line) > 1:
        bond_types_num = bond_types_num + 1
    else:
        break

# Number of Angle Types

for line in pote_data:
    if line.find('Angle Coeffs') != -1:
        angle_types_line = pote_data.index(line)

for angle_types_x in range((angle_types_line+2), final_line):
    inspect_line = pote_data[angle_types_x].split()
    if len(inspect_line) > 1:
        angle_types_num = angle_types_num + 1
    else:
        break


# Number of Dihedral Types

for line in pote_data:
    if line.find('Dihedral Coeffs') != -1:
        dihedral_types_line = pote_data.index(line)

for dihedral_types_x in range((dihedral_types_line+2), final_line):
    inspect_line = pote_data[dihedral_types_x].split()
    if len(inspect_line) > 1:
        dihedral_types_num = dihedral_types_num + 1
    else:
        break

# Number of Improper Types

for line in pote_data:
    if line.find('Improper Coeffs') != -1:
        improper_types_line = pote_data.index(line)

for improper_types_x in range((improper_types_line+2), final_line):
    inspect_line = pote_data[improper_types_x].split()
    if len(inspect_line) > 1:
        improper_types_num = improper_types_num + 1
    else:
        break

# Access CrySPY generated coordinates

cryspy_coords = "lammps.lattice.dat"
    
cryspy_text = open(cryspy_coords, 'r').readlines()

atoms_line = 0

for line in cryspy_text:
    if line.find('Atoms') != -1:
        atoms_line = cryspy_text.index(line)

final_line = len(cryspy_text)
    
coord_ctr= 0
    
for coord in range(atoms_line + 2, final_line):
    
    coord_line = cryspy_text[coord].split()
    coord_line.insert(2, ordered_charges[coord_ctr])
    coord_line.insert(1, ' 1 ')
    coord_ctr = coord_ctr + 1
        
    save_coords = str(coord_line[0] + ' ' + coord_line[1] + ' ' + coord_line[2] + ' ' + coord_line[3] + ' ' + \
                  coord_line[4] + ' ' + coord_line[5] + ' ' + coord_line[6] + '\n')

    cryspy_text[coord] = save_coords
        
# Insert additional header lines
    
bonds_str = str(bonds_num) + " bonds\n"
angles_str = str(angles_num) + " angles\n"
dihedrals_str = str(dihedrals_num) + " dihedrals\n"
impropers_str = str(impropers_num) + " impropers\n"
bond_types_str = str(bond_types_num) + " bond types\n"
angle_types_str = str(angle_types_num) + " angle types\n"
dihedral_types_str = str(dihedral_types_num) + " dihedral types\n"
improper_types_str = str(improper_types_num) + " improper types\n"
    
cryspy_text.insert(4, bonds_str)
cryspy_text.insert(5, angles_str)
cryspy_text.insert(6, dihedrals_str)
cryspy_text.insert(7, impropers_str)
cryspy_text.insert(8, '\n')
cryspy_text.insert(10, bond_types_str)
cryspy_text.insert(11, angle_types_str)
cryspy_text.insert(12, dihedral_types_str)
cryspy_text.insert(13, improper_types_str)
cryspy_text.insert(14, '\n')

# Delete existing file
os.remove(cryspy_coords)

final_line_new = len(cryspy_text)

# recreate with new data

with open(cryspy_coords, 'w') as f:
    
    for new_line in range(0, final_line_new):
        
        f.write(cryspy_text[new_line])

### END ###
